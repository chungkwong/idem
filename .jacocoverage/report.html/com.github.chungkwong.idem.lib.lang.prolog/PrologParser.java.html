<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PrologParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;MIDE&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.github.chungkwong.idem.lib.lang.prolog</a> &gt; <span class="el_source">PrologParser.java</span></div><h1>PrologParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Chan Chung Kwong &lt;1m02math@126.com&gt;
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package com.github.chungkwong.idem.lib.lang.prolog;
import com.github.chungkwong.idem.lib.*;
import static com.github.chungkwong.idem.lib.lang.prolog.OperatorTable.DEFAULT_OPERATOR_TABLE;
import java.util.*;
/**
 *
 * @author kwong
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class PrologParser implements SimpleIterator&lt;Predication&gt;{</span>
<span class="fc" id="L26">	private static final Operator curly=new Operator(&quot;{}&quot;,0,Operator.Class.PREFIX,Operator.Associativity.RIGHT);</span>
<span class="fc" id="L27">	private static final Operator openParen=new Operator(&quot;(&quot;,1202,Operator.Class.INFIX,Operator.Associativity.RIGHT);</span>
	PushBackIterator lex;
<span class="fc" id="L29">	public PrologParser(PrologLex lex){</span>
<span class="fc" id="L30">		this.lex=new PushBackIterator&lt;&gt;(new SimpleIteratorWraper&lt;&gt;(lex));</span>
<span class="fc" id="L31">	}</span>
	public List&lt;Predication&gt; getRemaining(){
<span class="fc" id="L33">		ArrayList&lt;Predication&gt; lst=new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">		Predication pred=next();</span>
<span class="fc bfc" id="L35" title="All 2 branches covered.">		while(pred!=null){</span>
<span class="fc" id="L36">			lst.add(pred);</span>
<span class="fc" id="L37">			pred=next();</span>
		}
<span class="fc" id="L39">		return lst;</span>
	}
	public Predication next(){
<span class="fc" id="L42">		ParseState state=new ParseState();</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">		out:while(lex.hasNext()){</span>
<span class="fc" id="L44">			Object token=lex.next();</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">			if(token instanceof Number){</span>
<span class="fc" id="L46">				state.pushOperand(new Atom(token));</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">			}else if(token instanceof Variable){</span>
<span class="fc" id="L48">				state.pushOperand((Variable)token);</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">			}else if(token instanceof String){</span>
<span class="fc" id="L50">				String name=(String)token;</span>
<span class="pc bpc" id="L51" title="6 of 26 branches missed.">				switch(name){</span>
<span class="fc" id="L52">					case &quot;(&quot;:state.pushOpenParen(lex);break;</span>
<span class="fc" id="L53">					case &quot;)&quot;:state.pushCloseParen();break;</span>
<span class="fc" id="L54">					case &quot;[&quot;:state.pushOpenBracket(lex);break;</span>
<span class="fc" id="L55">					case &quot;]&quot;:state.pushCloseBracket();break;</span>
<span class="fc" id="L56">					case &quot;{&quot;:state.pushOpenCurly(lex);break;</span>
<span class="fc" id="L57">					case &quot;}&quot;:state.pushCloseCurly();break;</span>
					default:
<span class="fc bfc" id="L59" title="All 2 branches covered.">						if(state.pushOperator(name,lex))</span>
<span class="fc" id="L60">							break out;</span>
				}
<span class="fc" id="L62">			}else{</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">				assert false;</span>
			}
			//System.err.println(state);
<span class="fc" id="L66">		}</span>
<span class="fc" id="L67">		state.end();</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">		if(state.operands.isEmpty())</span>
<span class="fc" id="L69">			return null;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">		if(state.operands.size()!=1)</span>
<span class="nc" id="L71">			throw new ParseException();</span>
<span class="fc" id="L72">		return (Predication)state.operands.pop();</span>
	}
	public static void main(String[] args){
<span class="nc" id="L75">		Scanner in=new Scanner(System.in);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">		while(in.hasNextLine()){</span>
<span class="nc" id="L77">			PrologParser parse=new PrologParser(new PrologLex(in.nextLine()));</span>
<span class="nc" id="L78">			System.out.println(parse.getRemaining());</span>
<span class="nc" id="L79">		}</span>
<span class="nc" id="L80">	}</span>
}
<span class="pc" id="L82">enum ExpectClass{</span>
<span class="fc" id="L83">	PREFIX,INFIX_OR_POSTFIX</span>
}
class ParseState{
<span class="fc" id="L86">	private static final Operator OPEN_PAREN=new Operator(&quot;(&quot;,1202,Operator.Class.INFIX,Operator.Associativity.RIGHT);</span>
<span class="fc" id="L87">	private static final Operator OPEN_BRACKET=new Operator(&quot;[&quot;,1202,Operator.Class.INFIX,Operator.Associativity.RIGHT);</span>
<span class="fc" id="L88">	private static final Operator OPEN_CURLY=new Operator(&quot;{&quot;,1202,Operator.Class.INFIX,Operator.Associativity.RIGHT);</span>
<span class="fc" id="L89">	private static final Atom EMPTY_LIST=new Atom(Collections.EMPTY_LIST);</span>
<span class="fc" id="L90">	Stack&lt;Term&gt; operands=new Stack&lt;&gt;();</span>
<span class="fc" id="L91">	Stack&lt;Operator&gt; operators=new Stack&lt;&gt;();</span>
<span class="fc" id="L92">	ExpectClass expected=ExpectClass.PREFIX;</span>
<span class="fc" id="L93">	ParseState(){</span>
<span class="fc" id="L94">		operators.push(new Operator(&quot;#&quot;,1202,Operator.Class.INFIX,Operator.Associativity.NO));</span>
<span class="fc" id="L95">	}</span>
	void pushOperand(Term term){
<span class="fc" id="L97">		operands.push(term);</span>
<span class="fc" id="L98">		expected=ExpectClass.INFIX_OR_POSTFIX;</span>
<span class="fc" id="L99">	}</span>
	boolean pushOperator(String name,PushBackIterator lex){
<span class="fc bfc" id="L101" title="All 2 branches covered.">		if(expected==ExpectClass.INFIX_OR_POSTFIX){</span>
<span class="fc" id="L102">			Operator infix=DEFAULT_OPERATOR_TABLE.getInfixOperators().get(name);</span>
<span class="fc" id="L103">			Operator postfix=DEFAULT_OPERATOR_TABLE.getPostfixOperators().get(name);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">			if(infix==null){</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">				if(postfix==null)</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">					if(name.equals(&quot;.&quot;))return true;</span>
<span class="nc" id="L107">					else throw new ParseException();</span>
				else
<span class="nc" id="L109">					pushOperator(postfix);</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">			}else if(postfix==null){</span>
<span class="fc" id="L111">				pushOperator(infix);</span>
			}else{
<span class="nc" id="L113">				Object peek=lex.peek();</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">				if(peek instanceof String&amp;&amp;(DEFAULT_OPERATOR_TABLE.getInfixOperators().containsKey(peek)</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">						||DEFAULT_OPERATOR_TABLE.getPostfixOperators().containsKey(peek))){</span>
<span class="nc" id="L116">					pushOperator(postfix);</span>
				}else{
<span class="nc" id="L118">					pushOperator(infix);</span>
				}
			}
<span class="fc" id="L121">		}else{</span>
<span class="fc" id="L122">			Object peek=lex.peek();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">			if(peek.equals(&quot;(&quot;)){</span>
<span class="fc" id="L124">				pushOperator(new Operator(name,0,Operator.Class.PREFIX,Operator.Associativity.RIGHT));</span>
			}else{
<span class="fc" id="L126">				Operator prefix=DEFAULT_OPERATOR_TABLE.getPrefixOperators().get(name);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">				if(prefix==null){</span>
<span class="fc" id="L128">					pushOperand(new Atom(name));</span>
				}else{
<span class="fc" id="L130">					pushOperator(prefix);</span>
				}
			}
		}
<span class="fc" id="L134">		return false;</span>
	}
	void pushOperator(Operator next){
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">		if(next.getCls()==Operator.Class.POSTFIX)</span>
<span class="nc" id="L138">			expected=ExpectClass.INFIX_OR_POSTFIX;</span>
		else
<span class="fc" id="L140">			expected=ExpectClass.PREFIX;</span>
		while(true){
<span class="fc" id="L142">			Operator top=operators.peek();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			if(top.getPriority()&lt;next.getPriority()){</span>
<span class="fc" id="L144">				reduceTopOperator();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">			}else if(top.getPriority()&gt;next.getPriority()){</span>
<span class="fc" id="L146">				break;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">			}else if(top.getAssociativity()==Operator.Associativity.LEFT){//top must be infix</span>
<span class="fc" id="L148">				reduceTopOperator();</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">			}else if(next.getAssociativity()==Operator.Associativity.RIGHT){</span>
<span class="fc" id="L150">				break;</span>
			}else{
<span class="nc" id="L152">				throw new ParseException();</span>
			}
<span class="fc" id="L154">		}</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if(next.getCls()==Operator.Class.POSTFIX)</span>
<span class="nc" id="L156">			operands.push(new CompoundTerm(next,Collections.singletonList(operands.pop())));</span>
		else
<span class="fc" id="L158">			operators.push(next);</span>
<span class="fc" id="L159">	}</span>
	void pushOpenBracket(PushBackIterator lex){
<span class="fc bfc" id="L161" title="All 2 branches covered.">		if(lex.peek().equals(&quot;]&quot;)){</span>
<span class="fc" id="L162">			lex.next();</span>
<span class="fc" id="L163">			pushOperand(EMPTY_LIST);</span>
		}else{
<span class="fc" id="L165">			operators.push(OPEN_BRACKET);</span>
<span class="fc" id="L166">			expected=ExpectClass.PREFIX;</span>
		}
<span class="fc" id="L168">	}</span>
	void pushOpenParen(PushBackIterator lex){
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">		if(lex.peek().equals(&quot;)&quot;)){</span>
<span class="nc" id="L171">			lex.next();</span>
<span class="nc" id="L172">			pushOperand(new CompoundTerm(operators.pop().getToken(),Collections.EMPTY_LIST));</span>
		}else{
<span class="fc" id="L174">			operators.push(OPEN_PAREN);</span>
<span class="fc" id="L175">			expected=ExpectClass.PREFIX;</span>
		}
<span class="fc" id="L177">	}</span>
	void pushOpenCurly(PushBackIterator lex){
<span class="fc bfc" id="L179" title="All 2 branches covered.">		if(lex.peek().equals(&quot;}&quot;)){</span>
<span class="fc" id="L180">			lex.next();</span>
<span class="fc" id="L181">			pushOperator(new Operator(&quot;{}&quot;,0,Operator.Class.PREFIX,Operator.Associativity.RIGHT));</span>
		}else{
<span class="fc" id="L183">			operators.push(OPEN_CURLY);</span>
<span class="fc" id="L184">			expected=ExpectClass.PREFIX;</span>
		}
<span class="fc" id="L186">	}</span>
	void pushCloseCurly(){
<span class="fc" id="L188">		LinkedList&lt;Term&gt; lst=new LinkedList&lt;&gt;();</span>
<span class="fc" id="L189">		Operator top=operators.peek();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		while(top!=OPEN_CURLY){</span>
<span class="nc" id="L191">			reduceTopOperator();</span>
<span class="nc" id="L192">			top=operators.peek();</span>
		}
<span class="fc" id="L194">		operators.pop();</span>
<span class="fc" id="L195">		operands.push(new CompoundTerm(&quot;{}&quot;,Collections.singletonList(operands.pop())));</span>
<span class="fc" id="L196">	}</span>
	void pushCloseBracket(){
<span class="fc" id="L198">		Operator top=operators.peek();</span>
<span class="fc" id="L199">		Term lst=EMPTY_LIST;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">		while(top!=OPEN_BRACKET){</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			if(top.getToken().equals(&quot;,&quot;)){</span>
<span class="fc" id="L202">				operators.pop();</span>
<span class="fc" id="L203">				lst=new CompoundTerm(&quot;.&quot;,Arrays.asList(operands.pop(),lst));</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">			}else if(top.getToken().equals(&quot;|&quot;)){</span>
<span class="fc" id="L205">				operators.pop();</span>
<span class="fc" id="L206">				lst=operands.pop();</span>
			}else
<span class="nc" id="L208">				reduceTopOperator();</span>
<span class="fc" id="L209">			top=operators.peek();</span>
		}
<span class="fc" id="L211">		operators.pop();</span>
<span class="fc" id="L212">		operands.push(new CompoundTerm(&quot;.&quot;,Arrays.asList(operands.pop(),lst)));</span>
<span class="fc" id="L213">	}</span>
	private static List&lt;Term&gt; convertTermtoList(Term t,boolean multi){
<span class="fc bfc" id="L215" title="All 2 branches covered.">		if(multi){</span>
<span class="fc" id="L216">			List&lt;Term&gt; lst=new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L217" title="All 4 branches covered.">			while(t instanceof CompoundTerm&amp;&amp;((CompoundTerm)t).getFunctor().equals(&quot;,&quot;)){</span>
<span class="fc" id="L218">				lst.add(((CompoundTerm)t).getArguments().get(0));</span>
<span class="fc" id="L219">				t=((CompoundTerm)t).getArguments().get(1);</span>
			}
<span class="fc" id="L221">			lst.add(t);</span>
<span class="fc" id="L222">			return lst;</span>
		}else{
<span class="fc" id="L224">			return Collections.singletonList(t);</span>
		}
	}
	void pushCloseParen(){
<span class="fc" id="L228">		Operator top=operators.peek();</span>
<span class="fc" id="L229">		int multi=0;</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">		while(top!=OPEN_PAREN){</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">			if(top.getToken().equals(&quot;,&quot;)&amp;&amp;multi!=-1)</span>
<span class="fc" id="L232">				multi=1;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">			else if(top.getPriority()&gt;1000)//1000 is the priority of ','</span>
<span class="fc" id="L234">				multi=-1;</span>
<span class="fc" id="L235">			reduceTopOperator();</span>
<span class="fc" id="L236">			top=operators.peek();</span>
		}
<span class="fc" id="L238">		operators.pop();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">		if(operators.peek().getCls()==Operator.Class.PREFIX){</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			List&lt;Term&gt; arg=convertTermtoList(operands.pop(),multi==1);</span>
<span class="fc" id="L241">			operands.push(new CompoundTerm(operators.pop().getToken(),arg));</span>
		}
<span class="fc" id="L243">	}</span>
	void reduceTopOperator(){
<span class="fc" id="L245">		Operator top=operators.pop();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">		if(top.getCls()==Operator.Class.INFIX){</span>
<span class="fc" id="L247">			Term right=operands.pop();</span>
<span class="fc" id="L248">			operands.push(new CompoundTerm(top.getToken(),Arrays.asList(operands.pop(),right)));</span>
<span class="fc" id="L249">		}else{</span>
<span class="fc" id="L250">			operands.push(new CompoundTerm(top.getToken(),Collections.singletonList(operands.pop())));</span>
		}
<span class="fc" id="L252">	}</span>
	void end(){
<span class="fc bfc" id="L254" title="All 2 branches covered.">		while(operators.size()&gt;1)</span>
<span class="fc" id="L255">			reduceTopOperator();</span>
<span class="fc" id="L256">		expected=ExpectClass.PREFIX;</span>
<span class="fc" id="L257">	}</span>
	@Override
	public String toString(){
<span class="nc" id="L260">		return &quot;Operands=&quot;+operands+&quot;\nOperators=&quot;+operators+&quot;\nExpected=&quot;+expected;</span>
	}
}
class ParseException extends RuntimeException{
	public ParseException(){
<span class="nc" id="L265">		super(&quot;Failed to parse&quot;);</span>
<span class="nc" id="L266">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>